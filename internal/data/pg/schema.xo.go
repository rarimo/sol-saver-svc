// Package pg contains generated code for schema 'public'.
package pg

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"

	"gitlab.com/distributed_lab/kit/pgdb"
	"gitlab.com/distributed_lab/logan/v3/errors"
	"gitlab.com/rarify-protocol/sol-saver-svc/internal/data"
)

// Storage is the helper struct for database operations
type Storage struct {
	db *pgdb.DB
}

// New - returns new instance of storage
func New(db *pgdb.DB) *Storage {
	return &Storage{
		db,
	}
}

// DB - returns db used by Storage
func (s *Storage) DB() *pgdb.DB {
	return s.db
}

// Clone - returns new storage with clone of db
func (s *Storage) Clone() *Storage {
	return New(s.db.Clone())
}

// Transaction begins a transaction on repo.
func (s *Storage) Transaction(tx func() error) error {
	return s.db.Transaction(tx)
} // FtDepositQ represents helper struct to access row of 'ft_deposits'.
type FtDepositQ struct {
	db *pgdb.DB
}

// NewFtDepositQ  - creates new instance
func NewFtDepositQ(db *pgdb.DB) *FtDepositQ {
	return &FtDepositQ{
		db,
	}
}

// FtDepositQ  - creates new instance of FtDepositQ
func (s Storage) FtDepositQ() *FtDepositQ {
	return NewFtDepositQ(s.DB())
}

var colsFtDeposit = `id, hash, instruction_id, sender, receiver, target_network, amount, mint, bundle_data, bundle_seed`

// InsertCtx inserts a FtDeposit to the database.
func (q FtDepositQ) InsertCtx(ctx context.Context, fd *data.FtDeposit) error {
	// insert (primary key generated and returned by database)
	sqlstr := `INSERT INTO public.ft_deposits (` +
		`hash, instruction_id, sender, receiver, target_network, amount, mint, bundle_data, bundle_seed` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9` +
		`) RETURNING id`
		// run

	err := q.db.GetRawContext(ctx, &fd.ID, sqlstr, fd.Hash, fd.InstructionID, fd.Sender, fd.Receiver, fd.TargetNetwork, fd.Amount, fd.Mint, fd.BundleData, fd.BundleSeed)
	if err != nil {
		return errors.Wrap(err, "failed to execute insert")
	}

	return nil
}

// Insert insert a FtDeposit to the database.
func (q FtDepositQ) Insert(fd *data.FtDeposit) error {
	return q.InsertCtx(context.Background(), fd)
}

// UpdateCtx updates a FtDeposit in the database.
func (q FtDepositQ) UpdateCtx(ctx context.Context, fd *data.FtDeposit) error {
	// update with composite primary key
	sqlstr := `UPDATE public.ft_deposits SET ` +
		`hash = $1, instruction_id = $2, sender = $3, receiver = $4, target_network = $5, amount = $6, mint = $7, bundle_data = $8, bundle_seed = $9 ` +
		`WHERE id = $10`
	// run
	err := q.db.ExecRawContext(ctx, sqlstr, fd.Hash, fd.InstructionID, fd.Sender, fd.Receiver, fd.TargetNetwork, fd.Amount, fd.Mint, fd.BundleData, fd.BundleSeed, fd.ID)
	return errors.Wrap(err, "failed to execute update")
}

// Update updates a FtDeposit in the database.
func (q FtDepositQ) Update(fd *data.FtDeposit) error {
	return q.UpdateCtx(context.Background(), fd)
}

// UpsertCtx performs an upsert for FtDeposit.
func (q FtDepositQ) UpsertCtx(ctx context.Context, fd *data.FtDeposit) error {
	// upsert
	sqlstr := `INSERT INTO public.ft_deposits (` +
		`id, hash, instruction_id, sender, receiver, target_network, amount, mint, bundle_data, bundle_seed` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`hash = EXCLUDED.hash, instruction_id = EXCLUDED.instruction_id, sender = EXCLUDED.sender, receiver = EXCLUDED.receiver, target_network = EXCLUDED.target_network, amount = EXCLUDED.amount, mint = EXCLUDED.mint, bundle_data = EXCLUDED.bundle_data, bundle_seed = EXCLUDED.bundle_seed `
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, fd.ID, fd.Hash, fd.InstructionID, fd.Sender, fd.Receiver, fd.TargetNetwork, fd.Amount, fd.Mint, fd.BundleData, fd.BundleSeed); err != nil {
		return errors.Wrap(err, "failed to execute upsert stmt")
	}
	return nil
}

// Upsert performs an upsert for FtDeposit.
func (q FtDepositQ) Upsert(fd *data.FtDeposit) error {
	return q.UpsertCtx(context.Background(), fd)
}

// DeleteCtx deletes the FtDeposit from the database.
func (q FtDepositQ) DeleteCtx(ctx context.Context, fd *data.FtDeposit) error {
	// delete with single primary key
	sqlstr := `DELETE FROM public.ft_deposits ` +
		`WHERE id = $1`
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, fd.ID); err != nil {
		return errors.Wrap(err, "failed to exec delete stmt")
	}
	return nil
}

// Delete deletes the FtDeposit from the database.
func (q FtDepositQ) Delete(fd *data.FtDeposit) error {
	return q.DeleteCtx(context.Background(), fd)
} // GorpMigrationQ represents helper struct to access row of 'gorp_migrations'.
type GorpMigrationQ struct {
	db *pgdb.DB
}

// NewGorpMigrationQ  - creates new instance
func NewGorpMigrationQ(db *pgdb.DB) *GorpMigrationQ {
	return &GorpMigrationQ{
		db,
	}
}

// GorpMigrationQ  - creates new instance of GorpMigrationQ
func (s Storage) GorpMigrationQ() *GorpMigrationQ {
	return NewGorpMigrationQ(s.DB())
}

var colsGorpMigration = `id, applied_at`

// InsertCtx inserts a GorpMigration to the database.
func (q GorpMigrationQ) InsertCtx(ctx context.Context, gm *data.GorpMigration) error {
	// sql insert query, primary key must be provided
	sqlstr := `INSERT INTO public.gorp_migrations (` +
		`id, applied_at` +
		`) VALUES (` +
		`$1, $2` +
		`)`
	// run
	err := q.db.ExecRawContext(ctx, sqlstr, gm.ID, gm.AppliedAt)
	return errors.Wrap(err, "failed to execute insert query")
}

// Insert insert a GorpMigration to the database.
func (q GorpMigrationQ) Insert(gm *data.GorpMigration) error {
	return q.InsertCtx(context.Background(), gm)
}

// UpdateCtx updates a GorpMigration in the database.
func (q GorpMigrationQ) UpdateCtx(ctx context.Context, gm *data.GorpMigration) error {
	// update with composite primary key
	sqlstr := `UPDATE public.gorp_migrations SET ` +
		`applied_at = $1 ` +
		`WHERE id = $2`
	// run
	err := q.db.ExecRawContext(ctx, sqlstr, gm.AppliedAt, gm.ID)
	return errors.Wrap(err, "failed to execute update")
}

// Update updates a GorpMigration in the database.
func (q GorpMigrationQ) Update(gm *data.GorpMigration) error {
	return q.UpdateCtx(context.Background(), gm)
}

// UpsertCtx performs an upsert for GorpMigration.
func (q GorpMigrationQ) UpsertCtx(ctx context.Context, gm *data.GorpMigration) error {
	// upsert
	sqlstr := `INSERT INTO public.gorp_migrations (` +
		`id, applied_at` +
		`) VALUES (` +
		`$1, $2` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`applied_at = EXCLUDED.applied_at `
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, gm.ID, gm.AppliedAt); err != nil {
		return errors.Wrap(err, "failed to execute upsert stmt")
	}
	return nil
}

// Upsert performs an upsert for GorpMigration.
func (q GorpMigrationQ) Upsert(gm *data.GorpMigration) error {
	return q.UpsertCtx(context.Background(), gm)
}

// DeleteCtx deletes the GorpMigration from the database.
func (q GorpMigrationQ) DeleteCtx(ctx context.Context, gm *data.GorpMigration) error {
	// delete with single primary key
	sqlstr := `DELETE FROM public.gorp_migrations ` +
		`WHERE id = $1`
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, gm.ID); err != nil {
		return errors.Wrap(err, "failed to exec delete stmt")
	}
	return nil
}

// Delete deletes the GorpMigration from the database.
func (q GorpMigrationQ) Delete(gm *data.GorpMigration) error {
	return q.DeleteCtx(context.Background(), gm)
} // NativeDepositQ represents helper struct to access row of 'native_deposits'.
type NativeDepositQ struct {
	db *pgdb.DB
}

// NewNativeDepositQ  - creates new instance
func NewNativeDepositQ(db *pgdb.DB) *NativeDepositQ {
	return &NativeDepositQ{
		db,
	}
}

// NativeDepositQ  - creates new instance of NativeDepositQ
func (s Storage) NativeDepositQ() *NativeDepositQ {
	return NewNativeDepositQ(s.DB())
}

var colsNativeDeposit = `id, hash, instruction_id, sender, receiver, target_network, amount, bundle_data, bundle_seed`

// InsertCtx inserts a NativeDeposit to the database.
func (q NativeDepositQ) InsertCtx(ctx context.Context, nd *data.NativeDeposit) error {
	// insert (primary key generated and returned by database)
	sqlstr := `INSERT INTO public.native_deposits (` +
		`hash, instruction_id, sender, receiver, target_network, amount, bundle_data, bundle_seed` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8` +
		`) RETURNING id`
		// run

	err := q.db.GetRawContext(ctx, &nd.ID, sqlstr, nd.Hash, nd.InstructionID, nd.Sender, nd.Receiver, nd.TargetNetwork, nd.Amount, nd.BundleData, nd.BundleSeed)
	if err != nil {
		return errors.Wrap(err, "failed to execute insert")
	}

	return nil
}

// Insert insert a NativeDeposit to the database.
func (q NativeDepositQ) Insert(nd *data.NativeDeposit) error {
	return q.InsertCtx(context.Background(), nd)
}

// UpdateCtx updates a NativeDeposit in the database.
func (q NativeDepositQ) UpdateCtx(ctx context.Context, nd *data.NativeDeposit) error {
	// update with composite primary key
	sqlstr := `UPDATE public.native_deposits SET ` +
		`hash = $1, instruction_id = $2, sender = $3, receiver = $4, target_network = $5, amount = $6, bundle_data = $7, bundle_seed = $8 ` +
		`WHERE id = $9`
	// run
	err := q.db.ExecRawContext(ctx, sqlstr, nd.Hash, nd.InstructionID, nd.Sender, nd.Receiver, nd.TargetNetwork, nd.Amount, nd.BundleData, nd.BundleSeed, nd.ID)
	return errors.Wrap(err, "failed to execute update")
}

// Update updates a NativeDeposit in the database.
func (q NativeDepositQ) Update(nd *data.NativeDeposit) error {
	return q.UpdateCtx(context.Background(), nd)
}

// UpsertCtx performs an upsert for NativeDeposit.
func (q NativeDepositQ) UpsertCtx(ctx context.Context, nd *data.NativeDeposit) error {
	// upsert
	sqlstr := `INSERT INTO public.native_deposits (` +
		`id, hash, instruction_id, sender, receiver, target_network, amount, bundle_data, bundle_seed` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`hash = EXCLUDED.hash, instruction_id = EXCLUDED.instruction_id, sender = EXCLUDED.sender, receiver = EXCLUDED.receiver, target_network = EXCLUDED.target_network, amount = EXCLUDED.amount, bundle_data = EXCLUDED.bundle_data, bundle_seed = EXCLUDED.bundle_seed `
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, nd.ID, nd.Hash, nd.InstructionID, nd.Sender, nd.Receiver, nd.TargetNetwork, nd.Amount, nd.BundleData, nd.BundleSeed); err != nil {
		return errors.Wrap(err, "failed to execute upsert stmt")
	}
	return nil
}

// Upsert performs an upsert for NativeDeposit.
func (q NativeDepositQ) Upsert(nd *data.NativeDeposit) error {
	return q.UpsertCtx(context.Background(), nd)
}

// DeleteCtx deletes the NativeDeposit from the database.
func (q NativeDepositQ) DeleteCtx(ctx context.Context, nd *data.NativeDeposit) error {
	// delete with single primary key
	sqlstr := `DELETE FROM public.native_deposits ` +
		`WHERE id = $1`
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, nd.ID); err != nil {
		return errors.Wrap(err, "failed to exec delete stmt")
	}
	return nil
}

// Delete deletes the NativeDeposit from the database.
func (q NativeDepositQ) Delete(nd *data.NativeDeposit) error {
	return q.DeleteCtx(context.Background(), nd)
} // NftDepositQ represents helper struct to access row of 'nft_deposits'.
type NftDepositQ struct {
	db *pgdb.DB
}

// NewNftDepositQ  - creates new instance
func NewNftDepositQ(db *pgdb.DB) *NftDepositQ {
	return &NftDepositQ{
		db,
	}
}

// NftDepositQ  - creates new instance of NftDepositQ
func (s Storage) NftDepositQ() *NftDepositQ {
	return NewNftDepositQ(s.DB())
}

var colsNftDeposit = `id, hash, instruction_id, sender, receiver, target_network, mint, collection, bundle_data, bundle_seed`

// InsertCtx inserts a NftDeposit to the database.
func (q NftDepositQ) InsertCtx(ctx context.Context, nd *data.NftDeposit) error {
	// insert (primary key generated and returned by database)
	sqlstr := `INSERT INTO public.nft_deposits (` +
		`hash, instruction_id, sender, receiver, target_network, mint, collection, bundle_data, bundle_seed` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9` +
		`) RETURNING id`
		// run

	err := q.db.GetRawContext(ctx, &nd.ID, sqlstr, nd.Hash, nd.InstructionID, nd.Sender, nd.Receiver, nd.TargetNetwork, nd.Mint, nd.Collection, nd.BundleData, nd.BundleSeed)
	if err != nil {
		return errors.Wrap(err, "failed to execute insert")
	}

	return nil
}

// Insert insert a NftDeposit to the database.
func (q NftDepositQ) Insert(nd *data.NftDeposit) error {
	return q.InsertCtx(context.Background(), nd)
}

// UpdateCtx updates a NftDeposit in the database.
func (q NftDepositQ) UpdateCtx(ctx context.Context, nd *data.NftDeposit) error {
	// update with composite primary key
	sqlstr := `UPDATE public.nft_deposits SET ` +
		`hash = $1, instruction_id = $2, sender = $3, receiver = $4, target_network = $5, mint = $6, collection = $7, bundle_data = $8, bundle_seed = $9 ` +
		`WHERE id = $10`
	// run
	err := q.db.ExecRawContext(ctx, sqlstr, nd.Hash, nd.InstructionID, nd.Sender, nd.Receiver, nd.TargetNetwork, nd.Mint, nd.Collection, nd.BundleData, nd.BundleSeed, nd.ID)
	return errors.Wrap(err, "failed to execute update")
}

// Update updates a NftDeposit in the database.
func (q NftDepositQ) Update(nd *data.NftDeposit) error {
	return q.UpdateCtx(context.Background(), nd)
}

// UpsertCtx performs an upsert for NftDeposit.
func (q NftDepositQ) UpsertCtx(ctx context.Context, nd *data.NftDeposit) error {
	// upsert
	sqlstr := `INSERT INTO public.nft_deposits (` +
		`id, hash, instruction_id, sender, receiver, target_network, mint, collection, bundle_data, bundle_seed` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`hash = EXCLUDED.hash, instruction_id = EXCLUDED.instruction_id, sender = EXCLUDED.sender, receiver = EXCLUDED.receiver, target_network = EXCLUDED.target_network, mint = EXCLUDED.mint, collection = EXCLUDED.collection, bundle_data = EXCLUDED.bundle_data, bundle_seed = EXCLUDED.bundle_seed `
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, nd.ID, nd.Hash, nd.InstructionID, nd.Sender, nd.Receiver, nd.TargetNetwork, nd.Mint, nd.Collection, nd.BundleData, nd.BundleSeed); err != nil {
		return errors.Wrap(err, "failed to execute upsert stmt")
	}
	return nil
}

// Upsert performs an upsert for NftDeposit.
func (q NftDepositQ) Upsert(nd *data.NftDeposit) error {
	return q.UpsertCtx(context.Background(), nd)
}

// DeleteCtx deletes the NftDeposit from the database.
func (q NftDepositQ) DeleteCtx(ctx context.Context, nd *data.NftDeposit) error {
	// delete with single primary key
	sqlstr := `DELETE FROM public.nft_deposits ` +
		`WHERE id = $1`
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, nd.ID); err != nil {
		return errors.Wrap(err, "failed to exec delete stmt")
	}
	return nil
}

// Delete deletes the NftDeposit from the database.
func (q NftDepositQ) Delete(nd *data.NftDeposit) error {
	return q.DeleteCtx(context.Background(), nd)
}

// FtDepositByIDCtx retrieves a row from 'public.ft_deposits' as a FtDeposit.
//
// Generated from index 'ft_deposits_pkey'.
func (q FtDepositQ) FtDepositByIDCtx(ctx context.Context, id int64, isForUpdate bool) (*data.FtDeposit, error) {
	// query
	sqlstr := `SELECT ` +
		`id, hash, instruction_id, sender, receiver, target_network, amount, mint, bundle_data, bundle_seed ` +
		`FROM public.ft_deposits ` +
		`WHERE id = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res data.FtDeposit
	err := q.db.GetRawContext(ctx, &res, sqlstr, id)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, nil
		}

		return nil, errors.Wrap(err, "failed to exec select")
	}

	return &res, nil
}

// FtDepositByID retrieves a row from 'public.ft_deposits' as a FtDeposit.
//
// Generated from index 'ft_deposits_pkey'.
func (q FtDepositQ) FtDepositByID(id int64, isForUpdate bool) (*data.FtDeposit, error) {
	return q.FtDepositByIDCtx(context.Background(), id, isForUpdate)
}

// FtDepositByHashInstructionIDCtx retrieves a row from 'public.ft_deposits' as a FtDeposit.
//
// Generated from index 'ft_index'.
func (q FtDepositQ) FtDepositByHashInstructionIDCtx(ctx context.Context, hash string, instructionID int, isForUpdate bool) (*data.FtDeposit, error) {
	// query
	sqlstr := `SELECT ` +
		`id, hash, instruction_id, sender, receiver, target_network, amount, mint, bundle_data, bundle_seed ` +
		`FROM public.ft_deposits ` +
		`WHERE hash = $1 AND instruction_id = $2`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res data.FtDeposit
	err := q.db.GetRawContext(ctx, &res, sqlstr, hash, instructionID)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, nil
		}

		return nil, errors.Wrap(err, "failed to exec select")
	}

	return &res, nil
}

// FtDepositByHashInstructionID retrieves a row from 'public.ft_deposits' as a FtDeposit.
//
// Generated from index 'ft_index'.
func (q FtDepositQ) FtDepositByHashInstructionID(hash string, instructionID int, isForUpdate bool) (*data.FtDeposit, error) {
	return q.FtDepositByHashInstructionIDCtx(context.Background(), hash, instructionID, isForUpdate)
}

// GorpMigrationByIDCtx retrieves a row from 'public.gorp_migrations' as a GorpMigration.
//
// Generated from index 'gorp_migrations_pkey'.
func (q GorpMigrationQ) GorpMigrationByIDCtx(ctx context.Context, id string, isForUpdate bool) (*data.GorpMigration, error) {
	// query
	sqlstr := `SELECT ` +
		`id, applied_at ` +
		`FROM public.gorp_migrations ` +
		`WHERE id = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res data.GorpMigration
	err := q.db.GetRawContext(ctx, &res, sqlstr, id)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, nil
		}

		return nil, errors.Wrap(err, "failed to exec select")
	}

	return &res, nil
}

// GorpMigrationByID retrieves a row from 'public.gorp_migrations' as a GorpMigration.
//
// Generated from index 'gorp_migrations_pkey'.
func (q GorpMigrationQ) GorpMigrationByID(id string, isForUpdate bool) (*data.GorpMigration, error) {
	return q.GorpMigrationByIDCtx(context.Background(), id, isForUpdate)
}

// NativeDepositByIDCtx retrieves a row from 'public.native_deposits' as a NativeDeposit.
//
// Generated from index 'native_deposits_pkey'.
func (q NativeDepositQ) NativeDepositByIDCtx(ctx context.Context, id int64, isForUpdate bool) (*data.NativeDeposit, error) {
	// query
	sqlstr := `SELECT ` +
		`id, hash, instruction_id, sender, receiver, target_network, amount, bundle_data, bundle_seed ` +
		`FROM public.native_deposits ` +
		`WHERE id = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res data.NativeDeposit
	err := q.db.GetRawContext(ctx, &res, sqlstr, id)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, nil
		}

		return nil, errors.Wrap(err, "failed to exec select")
	}

	return &res, nil
}

// NativeDepositByID retrieves a row from 'public.native_deposits' as a NativeDeposit.
//
// Generated from index 'native_deposits_pkey'.
func (q NativeDepositQ) NativeDepositByID(id int64, isForUpdate bool) (*data.NativeDeposit, error) {
	return q.NativeDepositByIDCtx(context.Background(), id, isForUpdate)
}

// NativeDepositByHashInstructionIDCtx retrieves a row from 'public.native_deposits' as a NativeDeposit.
//
// Generated from index 'native_index'.
func (q NativeDepositQ) NativeDepositByHashInstructionIDCtx(ctx context.Context, hash string, instructionID int, isForUpdate bool) (*data.NativeDeposit, error) {
	// query
	sqlstr := `SELECT ` +
		`id, hash, instruction_id, sender, receiver, target_network, amount, bundle_data, bundle_seed ` +
		`FROM public.native_deposits ` +
		`WHERE hash = $1 AND instruction_id = $2`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res data.NativeDeposit
	err := q.db.GetRawContext(ctx, &res, sqlstr, hash, instructionID)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, nil
		}

		return nil, errors.Wrap(err, "failed to exec select")
	}

	return &res, nil
}

// NativeDepositByHashInstructionID retrieves a row from 'public.native_deposits' as a NativeDeposit.
//
// Generated from index 'native_index'.
func (q NativeDepositQ) NativeDepositByHashInstructionID(hash string, instructionID int, isForUpdate bool) (*data.NativeDeposit, error) {
	return q.NativeDepositByHashInstructionIDCtx(context.Background(), hash, instructionID, isForUpdate)
}

// NftDepositByIDCtx retrieves a row from 'public.nft_deposits' as a NftDeposit.
//
// Generated from index 'nft_deposits_pkey'.
func (q NftDepositQ) NftDepositByIDCtx(ctx context.Context, id int64, isForUpdate bool) (*data.NftDeposit, error) {
	// query
	sqlstr := `SELECT ` +
		`id, hash, instruction_id, sender, receiver, target_network, mint, collection, bundle_data, bundle_seed ` +
		`FROM public.nft_deposits ` +
		`WHERE id = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res data.NftDeposit
	err := q.db.GetRawContext(ctx, &res, sqlstr, id)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, nil
		}

		return nil, errors.Wrap(err, "failed to exec select")
	}

	return &res, nil
}

// NftDepositByID retrieves a row from 'public.nft_deposits' as a NftDeposit.
//
// Generated from index 'nft_deposits_pkey'.
func (q NftDepositQ) NftDepositByID(id int64, isForUpdate bool) (*data.NftDeposit, error) {
	return q.NftDepositByIDCtx(context.Background(), id, isForUpdate)
}

// NftDepositByHashInstructionIDCtx retrieves a row from 'public.nft_deposits' as a NftDeposit.
//
// Generated from index 'nft_index'.
func (q NftDepositQ) NftDepositByHashInstructionIDCtx(ctx context.Context, hash string, instructionID int, isForUpdate bool) (*data.NftDeposit, error) {
	// query
	sqlstr := `SELECT ` +
		`id, hash, instruction_id, sender, receiver, target_network, mint, collection, bundle_data, bundle_seed ` +
		`FROM public.nft_deposits ` +
		`WHERE hash = $1 AND instruction_id = $2`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res data.NftDeposit
	err := q.db.GetRawContext(ctx, &res, sqlstr, hash, instructionID)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, nil
		}

		return nil, errors.Wrap(err, "failed to exec select")
	}

	return &res, nil
}

// NftDepositByHashInstructionID retrieves a row from 'public.nft_deposits' as a NftDeposit.
//
// Generated from index 'nft_index'.
func (q NftDepositQ) NftDepositByHashInstructionID(hash string, instructionID int, isForUpdate bool) (*data.NftDeposit, error) {
	return q.NftDepositByHashInstructionIDCtx(context.Background(), hash, instructionID, isForUpdate)
}
